/**
  * Copyright (c) Analog Devices Inc, 2020
  * All Rights Reserved.
  *
  * @file		isr.c
  * @date		4/27/2020
  * @author		A. Nolan (alex.nolan@analog.com)
  * @brief		iSensor-SPI-Buffer interrupt service routines (user provided)
 **/

#include "isr.h"

/* Private function prototypes */
static void FinishImuBurst();
static void FinishSlaveSpiBurst();

/** Global register array (from registers.c) */
volatile extern uint16_t g_regs[3 * REG_PER_PAGE];

/** Buffer internal count variable (from buffer.c) */
volatile extern uint32_t g_bufCount;

/* Update processing required (from registers.c) */
volatile extern uint32_t g_update_flags;

/** User SPI Rx DMA (from main.c) */
extern DMA_HandleTypeDef g_dma_spi2_rx;

/** User SPI Rx DMA (from main.c) */
extern DMA_HandleTypeDef g_dma_spi2_tx;

/** IMU SPI Rx DMA (from main.c) */
extern DMA_HandleTypeDef g_dma_spi1_rx;

/** IMU SPI Rx DMA (from main.c) */
extern DMA_HandleTypeDef g_dma_spi1_tx;

/** IMU SPI handle (from main.c) */
extern SPI_HandleTypeDef g_spi1;

/** Buffer to receive burst DMA data (from master) into (from burst.c)  */
extern uint8_t g_BurstRxData[74];

/** Current capture size (in 16 bit words). Global scope */
volatile uint32_t g_wordsPerCapture;

/** Track if there is currently a capture in progress */
volatile uint32_t g_captureInProgress;

/** Pointer to buffer element which is being populated */
static uint8_t* BufferElementHandle;

/** Pointer to buffer data signature within buffer element which is being populated */
static uint16_t* BufferSigHandle;

/** Track number of words captured within current buffer entry */
static volatile uint32_t WordsCaptured;

/** Buffer signature */
static uint32_t BufferSignature;

/** SPI MISO data */
static uint32_t SPIMISO;

/** Flag to track if IMU burst DMA is done */
static volatile uint32_t ImuDMADone = 0;

/** Flag to track if user burst DMA is done */
static volatile uint32_t SlaveSpiDMADone = 0;

/**
  * @brief IMU data ready ISR. Kicks off data capture process.
  *
  * @return void
  *
  * All four DIOx_Master pins map to this interrupt handler. Only one
  * should be enabled as an interrupt source at a time. This interrupt
  * also handles PPS input signals for DIO2-4. The EXTI pending interrupt
  * register (PR) can be used to identify if the interrupt is coming from
  * a PPS strobe or an IMU data ready signal.
  */
void EXTI9_5_IRQHandler()
{
	/* EXTI pending request register */
	static uint32_t EXTI_PR;

	/* Microsecond sample time stamp */
	static uint32_t SampleTimestampUs;

	/* Second sample time stamp */
	static uint32_t SampleTimestampS;

	/* Clear exti PR register (lines 5-9) */
	EXTI_PR = EXTI->PR;
	EXTI->PR |= 0x1F << 5;

	/* Check if is PPS interrupt */
	if(EXTI_PR & (PPS_INT_MASK))
	{
		/* Increment PPS counter and clear microsecond timestamp */
		IncrementPPSTime();
	}

	/* Exit if no data ready interrupt */
	if(!(EXTI_PR & (DATA_READY_INT_MASK)))
	{
		return;
	}

	/* If capture in progress then set error flag and exit */
	if(g_captureInProgress)
	{
		/* If SPI DMA and timer 4 are not running then capture is not actually in progress */
		g_captureInProgress = (TIM4->CR1 | g_dma_spi1_tx.Instance->CCR) & 0x1;
		g_regs[STATUS_0_REG] |= STATUS_OVERRUN;
		g_regs[STATUS_1_REG] = g_regs[STATUS_0_REG];
		return;
	}

	/* If buffer element cannot be added then exit */
	if(!BufCanAddElement())
		return;

	/* Get the sample timestamp */
	SampleTimestampS = GetPPSTimestamp();
	SampleTimestampUs = GetMicrosecondTimestamp();

	/* Get element handle */
	BufferElementHandle = BufAddElement();

	/* Add timestamp to buffer */
	*(uint32_t *) BufferElementHandle = SampleTimestampS;
	*(uint32_t *) (BufferElementHandle + 4) = SampleTimestampUs;

	/* Set signature to timestamp value initially */
	BufferSignature = SampleTimestampS & 0xFFFF;
	BufferSignature += (SampleTimestampS >> 16);
	BufferSignature += SampleTimestampUs & 0xFFFF;
	BufferSignature += (SampleTimestampUs >> 16);

	/* Set buffer signature handle */
	BufferSigHandle = (uint16_t *) (BufferElementHandle + 8);

	/* Offset buffer element handle by 10 bytes (timestamp + sig) */
	BufferElementHandle += 10;

	/* Set flag indicating capture is running */
	g_captureInProgress = 1;

	if(g_regs[BUF_CONFIG_REG] & 0x2)
	{
		ImuDMADone = 0;
		StartImuBurst(BufferElementHandle);
	}
	else
	{
		/* Register SPI data capture */

		/* Set words captured to 0 */
		WordsCaptured = 0;

		/*Set timer value to 0 */
		TIM4->CNT = 0;
		/* Enable timer */
		TIM4->CR1 |= 0x1;
		/* Clear timer interrupt flag */
		TIM4->SR &= ~TIM_SR_UIF;

		/* Send first 16 bit word */
		TIM3->CR1 &= ~0x1;
		TIM3->CNT = 0;
		TIM3->CR1 |= 0x1;
		SPI1->DR = g_regs[BUF_WRITE_0_REG];
	}
}

/**
  * @brief EXTI 4 interrupt handler.
  *
  * @return void
  *
  * This interrupt is generated by a PPS signal applied to
  * DIO1
  */
void EXTI4_IRQHandler()
{
	/* Clear pending interrupts */
	EXTI->PR |= (1 << 4);

	/* Increment PPS timestamp */
	IncrementPPSTime();
}

/**
  * @brief IMU SPI timer ISR.
  *
  * @return void
  *
  * This interrupt retrieves the SPI data read on the previous SPI transaction. It
  * then starts the next SPI transaction (if needed) and returns.
  */
void TIM4_IRQHandler()
{
	/* Clear timer interrupt flag */
	TIM4->SR &= ~TIM_SR_UIF;

	/* Reset timer count. Want to reset it to give a ~0.7us offset */
	TIM4->CNT = 50;

	/* Disable CS timer */
	TIM3->CR1 = 0;
	TIM3->CNT = 0xFFFF;

	if(!g_captureInProgress)
	{
		/* Disable timers */
		TIM4->CR1 &= ~0x1;
		return;
	}

	/* Wait for SPI rx done */
	while(!(SPI1->SR & SPI_SR_RXNE));

	/* Grab SPI data from last transaction */
	SPIMISO = SPI1->DR;

	/* Add to signature */
	BufferSignature += SPIMISO;

	BufferElementHandle[0] = (SPIMISO & 0xFF);
	BufferElementHandle[1] = (SPIMISO >> 8);
	BufferElementHandle += 2;

	/* Increment words captured count */
	WordsCaptured++;

	if(WordsCaptured < g_wordsPerCapture)
	{
		/* Restart PWM timer for CS */
		TIM3->CR1 |= 0x1;
		/* Load SPI transmit reg */
		SPI1->DR = g_regs[BUF_WRITE_0_REG + WordsCaptured];
	}
	else
	{
		/* Disable timers and ensure CS is high */
		TIM4->CR1 &= ~0x1;
		TIM3->CR1 &= ~0x1;
		TIM3->CNT = 0xFFFF;

		/* Save final signature */
		BufferSigHandle[0] = BufferSignature;

		/* Update buffer count regs with new count */
		g_regs[BUF_CNT_0_REG] = g_bufCount;
		g_regs[BUF_CNT_1_REG] = g_regs[BUF_CNT_0_REG];

		/* Mark capture as done */
		g_captureInProgress = 0;
	}
}

/**
  * @brief Slave SPI ISR
  *
  * @return void
  *
  * This function handles SPI traffic from the master device
  */
void SPI2_IRQHandler(void)
{
	uint32_t itflag = SPI2->SR;
	uint32_t transmitData;
	uint32_t rxData;

	/* Error interrupt source */
	if(itflag & (SPI_FLAG_OVR | SPI_FLAG_MODF))
	{
		/* Set status reg SPI error flag */
		g_regs[STATUS_0_REG] |= STATUS_SPI_ERROR;
		g_regs[STATUS_1_REG] = g_regs[STATUS_0_REG];

		/* Overrun error, can be cleared by repeatedly reading DR */
		for(uint32_t i = 0; i < 4; i++)
		{
			transmitData = SPI2->DR;
		}
		/* Load zero to output */
		SPI2->DR = 0;
		/* Read status register */
		itflag = SPI2->SR;
		/* Exit ISR */
		return;
	}

	/* Spi overflow (received transaction while transmit pending) */
	if(itflag & 0x1000)
	{
		/* Get data from FIFO */
		rxData = SPI2->DR;

		/* Set status reg SPI overflow flag */
		g_regs[STATUS_0_REG] |= STATUS_SPI_OVERFLOW;
		g_regs[STATUS_1_REG] = g_regs[STATUS_0_REG];

		/* Exit ISR */
		return;
	}

	/* Rx done interrupt source */
	if(itflag & SPI_FLAG_RXNE)
	{
		/* Get data from FIFO */
		rxData = SPI2->DR;

		/* Handle transaction */
		if(rxData & 0x8000)
		{
			/* Write */
			transmitData = WriteReg((rxData & 0x7F00) >> 8, rxData & 0xFF);
		}
		else
		{
			/* Read */
			transmitData = ReadReg(rxData >> 8);
		}

		/* Transmit data back */
		SPI2->DR = transmitData;
	}
}

/**
  * @brief This function handles DMA1 channel2 global interrupt (spi1 (IMU) Rx).
  *
  * @return void
  */
void DMA1_Channel2_IRQHandler(void)
{
	uint32_t flags = g_dma_spi1_rx.DmaBaseAddress->ISR;

	/* Clear interrupt enable */
	g_dma_spi1_rx.Instance->CCR &= ~(DMA_IT_TC | DMA_IT_TE);

	/* Clear interrupt flags */
	g_dma_spi1_rx.DmaBaseAddress->IFCR = (DMA_FLAG_TC1|DMA_FLAG_TE1) << g_dma_spi1_rx.ChannelIndex;

	/* Check for error interrupt */
	if(flags & (DMA_FLAG_TE1 << g_dma_spi1_rx.ChannelIndex))
	{
		g_regs[STATUS_0_REG] |= STATUS_DMA_ERROR;
		g_regs[STATUS_1_REG] = g_regs[STATUS_0_REG];
		FinishImuBurst();
	}

	/* Check if both interrupts complete */
	if(ImuDMADone == 0)
	{
	  ImuDMADone = 1;
	}
	else
	{
	  /* Both are done */
	  FinishImuBurst();
	}
}

/**
  * @brief This function handles DMA1 channel3 global interrupt (spi1 (IMU) Tx).
  *
  * @return void
  */
void DMA1_Channel3_IRQHandler(void)
{
	uint32_t flags = g_dma_spi1_tx.DmaBaseAddress->ISR;

	/* Clear interrupt enable */
	g_dma_spi1_tx.Instance->CCR &= ~(DMA_IT_TC | DMA_IT_TE);

	/* Clear interrupt flags */
	g_dma_spi1_tx.DmaBaseAddress->IFCR = (DMA_FLAG_TC1|DMA_FLAG_TE1) << g_dma_spi1_tx.ChannelIndex;

	/* Check for error interrupt */
	if(flags & (DMA_FLAG_TE1 << g_dma_spi1_tx.ChannelIndex))
	{
		g_regs[STATUS_0_REG] |= STATUS_DMA_ERROR;
		g_regs[STATUS_1_REG] = g_regs[STATUS_0_REG];
		FinishImuBurst();
	}

	/* Check if both interrupts complete */
	if(ImuDMADone == 0)
	{
	  ImuDMADone = 1;
	}
	else
	{
	  FinishImuBurst();
	}
}

/**
  * @brief Cleans up an IMU burst data read
  *
  * @return void
  *
  * This function is called once the SPI1 Tx and Rx DMA interrupts
  * have both fired, or a single error interrupt has been generated.
  * SPI1 uses DMA1, channel 2/3. These channels have lower priority
  * than the user SPI DMA channels, which also use DMA peripheral 1.
  *
  * This function brings CS high, calculates the buffer signature,
  * and updates the buffer count / capture state variables. Before
  * this function is called, DMA interrupts should be disabled (by
  * their respective ISR's)
  */
static void FinishImuBurst()
{
	/* Bring CS high */
	TIM3->CR1 &= ~0x1;
	TIM3->CNT = 0xFFFF;

	/* Build buffer signature */
	uint16_t * RxData = (uint16_t *) BufferElementHandle;
	for(int reg = 0; reg < (g_regs[BUF_LEN_REG] / 2); reg++)
	{
		BufferSignature += RxData[reg];
	}
	/* Save signature to buffer entry */
	BufferSigHandle[0] = BufferSignature;

	/* Update buffer count regs with new count */
	g_regs[BUF_CNT_0_REG] = g_bufCount;
	g_regs[BUF_CNT_1_REG] = g_regs[BUF_CNT_0_REG];

	/* Mark capture as done */
	g_captureInProgress = 0;
}

/**
  * @brief This function handles DMA1 channel4 global interrupt (spi2 (user) Rx).
  *
  * @return void
  */
void DMA1_Channel4_IRQHandler(void)
{
	uint32_t flags = g_dma_spi2_rx.DmaBaseAddress->ISR;

	/* Clear interrupt enable */
	g_dma_spi2_rx.Instance->CCR &= ~(DMA_IT_TC | DMA_IT_TE);

	/* Clear interrupt flags */
	g_dma_spi2_rx.DmaBaseAddress->IFCR = (DMA_FLAG_TC1|DMA_FLAG_TE1) << g_dma_spi2_rx.ChannelIndex;

	/* Check for error interrupt */
	if(flags & (DMA_FLAG_TE1 << g_dma_spi2_rx.ChannelIndex))
	{
		g_regs[STATUS_0_REG] |= STATUS_DMA_ERROR;
		g_regs[STATUS_1_REG] = g_regs[STATUS_0_REG];
		FinishSlaveSpiBurst();
	}

	/* Check if total transfer is done */
	if(SlaveSpiDMADone == 0)
		SlaveSpiDMADone = 1;
	else
		FinishSlaveSpiBurst();
}

/**
  * @brief This function handles DMA1 channel5 global interrupt (spi2 (user) Tx).
  *
  * @return void
  */
void DMA1_Channel5_IRQHandler(void)
{
	uint32_t flags = g_dma_spi2_tx.DmaBaseAddress->ISR;

	/* Clear interrupt enable */
	g_dma_spi2_tx.Instance->CCR &= ~(DMA_IT_TC | DMA_IT_TE);

	/* Clear interrupt flags */
	g_dma_spi2_tx.DmaBaseAddress->IFCR = (DMA_FLAG_TC1|DMA_FLAG_TE1) << g_dma_spi2_tx.ChannelIndex;

	/* Check for error interrupt */
	if(flags & (DMA_FLAG_TE1 << g_dma_spi2_tx.ChannelIndex))
	{
		g_regs[STATUS_0_REG] |= STATUS_DMA_ERROR;
		g_regs[STATUS_1_REG] = g_regs[STATUS_0_REG];
		FinishSlaveSpiBurst();
	}

	/* Check if total transfer is done */
	if(SlaveSpiDMADone == 0)
		SlaveSpiDMADone = 1;
	else
		FinishSlaveSpiBurst();
}

/**
  * @brief Cleans up a burst data read from a master device
  *
  * @return void
  *
  * This function is called once the SPI2 Tx and Rx DMA interrupts
  * have both fired, or a single error interrupt has been generated.
  * SPI2 uses DMA1, channel 4/5. These channels have higher priority
  * than the user SPI DMA channels, which also use DMA peripheral 1.
  *
  * This function reacts based on the data received from the master
  * device during the burst. If the master clocked out the address of
  * BUF_RETRIEVE register in the first byte, this function triggers another
  * buffer dequeue operation (which will set up another burst). If the first
  * byte received does not address the BUF_RETRIEVE register, then the SPI is returned
  * to register mode, and the standard SPI read/write routine is called with the
  * values received in the first two bytes.
  */
static void FinishSlaveSpiBurst()
{
	/* Reset slave SPI DMA done flag */
	SlaveSpiDMADone = 0;

	/* If Rx data has address for buf_retrieve then set up another burst */
	if((g_BurstRxData[1] == 6) && (g_regs[BUF_CNT_0_REG] > 0))
	{
		/* Load 0 into user SPI output */
		SPI2->DR = 0;

		/* Set update flag for main loop */
		g_update_flags |= DEQUEUE_BUF_FLAG;
	}
	/* Else restore register SPI mode */
	else
	{
		/* Disable burst */
		BurstReadDisable();

		/* Process data received in bytes 0 - 1 */
		if(g_BurstRxData[0] & 0x80)
		{
			/* Write */
			SPIMISO = WriteReg(g_BurstRxData[0] & 0x7F, g_BurstRxData[1]);
		}
		else
		{
			/* Read */
			SPIMISO = ReadReg(g_BurstRxData[0]);
		}

		/* Transmit data back */
		SPI2->DR = SPIMISO;
	}
}

/**
  * @brief This function handles Hard fault interrupt.
  *
  * @return void
  */
void HardFault_Handler(void)
{
	/* Store error message for future retrieval and reboot */
	FlashLogError(ERROR_HARDFAULT);
	NVIC_SystemReset();
}

/**
  * @brief This function handles Memory management fault.
  *
  * @return void
  */
void MemManage_Handler(void)
{
	/* Store error message for future retrieval and reboot */
	FlashLogError(ERROR_MEM);
	NVIC_SystemReset();
}

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  *
  * @return void
  */
void BusFault_Handler(void)
{
	/* Store error message for future retrieval and reboot */
	FlashLogError(ERROR_BUS);
	NVIC_SystemReset();
}

/**
  * @brief This function handles Undefined instruction or illegal state.
  *
  * @return void
  */
void UsageFault_Handler(void)
{
	/* Store error message for future retrieval and reboot */
	FlashLogError(ERROR_USAGE);
	NVIC_SystemReset();
}
