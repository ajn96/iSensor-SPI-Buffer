/**
  * Copyright (c) Analog Devices Inc, 2020
  * All Rights Reserved.
  *
  * @file		isr.c
  * @date		4/27/2020
  * @author		A. Nolan (alex.nolan@analog.com)
  * @brief		iSensor-SPI-Buffer interrupt service routines (user provided)
 **/

#include "isr.h"

static void FinishImuBurst();

/** Global register array (from registers.c) */
volatile extern uint16_t g_regs[3 * REG_PER_PAGE];

/** Buffer internal count variable (from buffer.c) */
volatile extern uint32_t g_bufCount;

/** User SPI Rx DMA (from main.c) */
extern DMA_HandleTypeDef g_dma_spi2_rx;

/** User SPI Rx DMA (from main.c) */
extern DMA_HandleTypeDef g_dma_spi2_tx;

/** IMU SPI Rx DMA (from main.c) */
extern DMA_HandleTypeDef g_dma_spi1_rx;

/** IMU SPI Rx DMA (from main.c) */
extern DMA_HandleTypeDef g_dma_spi1_tx;

extern SPI_HandleTypeDef g_spi1;

/** Current capture size (in 16 bit words). Global scope */
volatile uint32_t g_wordsPerCapture;

/** Track if there is currently a capture in progress */
volatile uint32_t g_captureInProgress;

/** Pointer to buffer element which is being populated */
static uint8_t* BufferElementHandle;

/** Pointer to buffer data signature within buffer element which is being populated */
static uint16_t* BufferSigHandle;

/** Track number of words captured within current buffer entry */
static volatile uint32_t WordsCaptured;

/** Microsecond sample time stamp */
static uint32_t SampleTimestampUs;

/** Second sample time stamp */
static uint32_t SampleTimestampS;

/** Buffer signature */
static uint32_t BufferSignature;

/** SPI MISO data */
static uint32_t SPIMISO;

/** EXTI pending request register */
static uint32_t EXTI_PR;

static uint32_t ImuDMADone;

/**
  * @brief IMU data ready ISR. Kicks off data capture process.
  *
  * @return void
  *
  * All four DIOx_Master pins map to this interrupt handler. Only one
  * should be enabled as an interrupt source at a time. This interrupt
  * also handles PPS input signals for DIO2-4. The EXTI pending interrupt
  * register (PR) can be used to identify if the interrupt is coming from
  * a PPS strobe or an IMU data ready signal.
  */
void EXTI9_5_IRQHandler()
{
	/* Clear exti PR register (lines 5-9) */
	EXTI_PR = EXTI->PR;
	EXTI->PR |= 0x1F << 5;

	/* Check if is PPS interrupt */
	if(EXTI_PR & (PPS_INT_MASK))
	{
		/* Increment PPS counter and clear microsecond timestamp */
		IncrementPPSTime();
	}

	/* Exit if no data ready interrupt */
	if(!(EXTI_PR & (DATA_READY_INT_MASK)))
	{
		return;
	}

	/* If capture in progress then set error flag and exit */
	if(g_captureInProgress)
	{
		g_captureInProgress = TIM4->CR1 & 0x1;
		g_regs[STATUS_0_REG] |= STATUS_OVERRUN;
		g_regs[STATUS_1_REG] = g_regs[STATUS_0_REG];
		return;
	}

	/* If buffer element cannot be added then exit */
	if(!BufCanAddElement())
		return;

	/* Get the sample timestamp */
	SampleTimestampS = GetPPSTimestamp();
	SampleTimestampUs = GetMicrosecondTimestamp();

	/* Get element handle */
	BufferElementHandle = BufAddElement();

	/* Add timestamp to buffer */
	*(uint32_t *) BufferElementHandle = SampleTimestampS;
	*(uint32_t *) (BufferElementHandle + 4) = SampleTimestampUs;

	/* Set signature to timestamp value initially */
	BufferSignature = SampleTimestampS & 0xFFFF;
	BufferSignature += (SampleTimestampS >> 16);
	BufferSignature += SampleTimestampUs & 0xFFFF;
	BufferSignature += (SampleTimestampUs >> 16);

	/* Set buffer signature handle */
	BufferSigHandle = (uint16_t *) (BufferElementHandle + 8);

	/* Offset buffer element handle by 10 bytes (timestamp + sig) */
	BufferElementHandle += 10;

	/* Set flag indicating capture is running */
	g_captureInProgress = 1;

	if(g_regs[BUF_CONFIG_REG] & 0x2)
	{
		ImuDMADone = 0;
		StartImuBurst(BufferElementHandle);
	}
	else
	{
		/* Register SPI data capture */

		/* Set words captured to 0 */
		WordsCaptured = 0;

		/*Set timer value to 0 */
		TIM4->CNT = 0;
		/* Enable timer */
		TIM4->CR1 |= 0x1;
		/* Clear timer interrupt flag */
		TIM4->SR &= ~TIM_SR_UIF;

		/* Send first 16 bit word */
		TIM3->CR1 &= ~0x1;
		TIM3->CNT = 0;
		TIM3->CR1 |= 0x1;
		SPI1->DR = g_regs[BUF_WRITE_0_REG];
	}
}

/**
  * @brief EXTI 4 interrupt handler.
  *
  * @return void
  *
  * This interrupt is generated by a PPS signal applied to
  * DIO1
  */
void EXTI4_IRQHandler()
{
	/* Clear pending interrupts */
	EXTI->PR |= (1 << 4);

	/* Increment PPS timestamp */
	IncrementPPSTime();
}

/**
  * @brief IMU SPI timer ISR.
  *
  * @return void
  *
  * This interrupt retrieves the SPI data read on the previous SPI transaction. It
  * then starts the next SPI transaction (if needed) and returns.
  */
void TIM4_IRQHandler()
{
	/* Clear timer interrupt flag */
	TIM4->SR &= ~TIM_SR_UIF;

	/* Reset timer count. Want to reset it to give a ~0.7us offset */
	TIM4->CNT = 50;

	/* Disable CS timer */
	TIM3->CR1 = 0;
	TIM3->CNT = 0xFFFF;

	if(!g_captureInProgress)
	{
		/* Disable timers */
		TIM4->CR1 &= ~0x1;
		return;
	}

	/* Wait for SPI rx done */
	while(!(SPI1->SR & SPI_SR_RXNE));

	/* Grab SPI data from last transaction */
	SPIMISO = SPI1->DR;

	/* Add to signature */
	BufferSignature += SPIMISO;

	BufferElementHandle[0] = (SPIMISO & 0xFF);
	BufferElementHandle[1] = (SPIMISO >> 8);
	BufferElementHandle += 2;

	/* Increment words captured count */
	WordsCaptured++;

	if(WordsCaptured < g_wordsPerCapture)
	{
		/* Restart PWM timer for CS */
		TIM3->CR1 |= 0x1;
		/* Load SPI transmit reg */
		SPI1->DR = g_regs[BUF_WRITE_0_REG + WordsCaptured];
	}
	else
	{
		/* Disable timers and ensure CS is high */
		TIM4->CR1 &= ~0x1;
		TIM3->CR1 &= ~0x1;
		TIM3->CNT = 0xFFFF;

		/* Save final signature */
		BufferSigHandle[0] = BufferSignature;

		/* Update buffer count regs with new count */
		g_regs[BUF_CNT_0_REG] = g_bufCount;
		g_regs[BUF_CNT_1_REG] = g_regs[BUF_CNT_0_REG];

		/* Mark capture as done */
		g_captureInProgress = 0;
	}
}

/**
  * @brief Slave SPI ISR
  *
  * @return void
  *
  * This function handles SPI traffic from the master device
  */
void SPI2_IRQHandler(void)
{
	uint32_t itflag = SPI2->SR;
	uint32_t transmitData;
	uint32_t rxData;

	/* Error interrupt source */
	if(itflag & (SPI_FLAG_OVR | SPI_FLAG_MODF))
	{
		/* Set status reg SPI error flag */
		g_regs[STATUS_0_REG] |= STATUS_SPI_ERROR;
		g_regs[STATUS_1_REG] = g_regs[STATUS_0_REG];

		/* Overrun error, can be cleared by repeatedly reading DR */
		for(uint32_t i = 0; i < 4; i++)
		{
			transmitData = SPI2->DR;
		}
		/* Load zero to output */
		SPI2->DR = 0;
		/* Read status register */
		itflag = SPI2->SR;
		/* Exit ISR */
		return;
	}

	/* Spi overflow (received transaction while transmit pending) */
	if(itflag & 0x1000)
	{
		/* Get data from FIFO */
		rxData = SPI2->DR;

		/* Set status reg SPI overflow flag */
		g_regs[STATUS_0_REG] |= STATUS_SPI_OVERFLOW;
		g_regs[STATUS_1_REG] = g_regs[STATUS_0_REG];

		/* Exit ISR */
		return;
	}

	/* Rx done interrupt source */
	if(itflag & SPI_FLAG_RXNE)
	{
		/* Get data from FIFO */
		rxData = SPI2->DR;

		/* Handle transaction */
		if(rxData & 0x8000)
		{
			/* Write */
			transmitData = WriteReg((rxData & 0x7F00) >> 8, rxData & 0xFF);
		}
		else
		{
			/* Read */
			transmitData = ReadReg(rxData >> 8);
		}

		/* Transmit data back */
		SPI2->DR = transmitData;
	}
}

/**
  * @brief This function handles DMA1 channel2 global interrupt (spi1 Rx).
  */
void DMA1_Channel2_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&g_dma_spi1_rx);
  if(ImuDMADone == 0)
  {
	  ImuDMADone = 1;
  }
  else
  {
	  /* Both are done */
	  FinishImuBurst();
  }
}

/**
  * @brief This function handles DMA1 channel3 global interrupt (spi1 Tx).
  */
void DMA1_Channel3_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&g_dma_spi1_tx);
  if(ImuDMADone == 0)
  {
	  ImuDMADone = 1;
  }
  else
  {
	  FinishImuBurst();
  }
}

static void FinishImuBurst()
{
	/* Bring CS high */
	TIM3->CR1 &= ~0x1;
	TIM3->CNT = 0xFFFF;

	/* Build buffer signature */
	uint16_t * RxData = (uint16_t *) BufferElementHandle;
	for(int reg = 0; reg < (g_regs[BUF_LEN_REG] / 2); reg++)
	{
		BufferSignature += RxData[reg];
	}
	/* Save to buffer entry */
	BufferSigHandle[0] = BufferSignature;

	/* Update buffer count regs with new count */
	g_regs[BUF_CNT_0_REG] = g_bufCount;
	g_regs[BUF_CNT_1_REG] = g_regs[BUF_CNT_0_REG];

	/* Mark capture as done */
	g_captureInProgress = 0;
}

/**
  * @brief This function handles DMA1 channel4 global interrupt (spi2 Rx).
  *
  * @return void
  */
void DMA1_Channel4_IRQHandler(void)
{
	HAL_DMA_IRQHandler(&g_dma_spi2_rx);
}

/**
  * @brief This function handles DMA1 channel5 global interrupt (spi2 Tx).
  *
  * @return void
  */
void DMA1_Channel5_IRQHandler(void)
{
	HAL_DMA_IRQHandler(&g_dma_spi2_tx);
}

/**
  * @brief This function handles Hard fault interrupt.
  *
  * @return void
  */
void HardFault_Handler(void)
{
	/* Store error message for future retrieval and reboot */
	FlashLogError(ERROR_HARDFAULT);
	NVIC_SystemReset();
}

/**
  * @brief This function handles Memory management fault.
  *
  * @return void
  */
void MemManage_Handler(void)
{
	/* Store error message for future retrieval and reboot */
	FlashLogError(ERROR_MEM);
	NVIC_SystemReset();
}

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  *
  * @return void
  */
void BusFault_Handler(void)
{
	/* Store error message for future retrieval and reboot */
	FlashLogError(ERROR_BUS);
	NVIC_SystemReset();
}

/**
  * @brief This function handles Undefined instruction or illegal state.
  *
  * @return void
  */
void UsageFault_Handler(void)
{
	/* Store error message for future retrieval and reboot */
	FlashLogError(ERROR_USAGE);
	NVIC_SystemReset();
}
